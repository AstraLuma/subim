#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
A dirt simple IM program for your local subnet.
"""
# SubIM, A dirt simple IM program for your local subnet.
# Copyright (C) 2007 James Bliss <james.bliss@astro73.com>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# 

#from __future__ import with_statement Compatibility with debian stable
from __future__ import division
import pygtk
pygtk.require('2.0')
import gtk
import gobject
gtk.gdk.threads_init()
gobject.threads_init()
import gtk.glade
import pango
import os, sys, socket, struct, threading
import traceback, datetime, re

# These 4 variables are settings, you may configure them as you wish.

# The IPv4 multicast group is 224.0.0.0/4
# The mcast.py demo uses 225.0.0.250, which is part of a reserved block
# The link scope is 239.255.0.0/16, the organization scope is 239.192.0.0/14
# I'm going to use the former, with the last 2 bytes being map(ord, 'SI'), 
# SI = SubIM, or 239.255.83.73
SUBIM_GROUP = '239.255.83.73'
# Set this to the number of hops packets can take. 1 is fine for most homes,
# Organizations or other more complex setups may need higher numbers.
SUBIM_TTL = 3

# Change this to 8123 to test with mcast.py found in the Python demos
# 5349 = "%02X%02X" % tuple(map(ord, 'SI')), SI = SubIM
SUBIM_PORT = 5349

# For the nick hasher
SATURATION = 1.00
LUMINANCE = 0.40

__author__ = "James Bliss <astronouth7303@gmail.com>"
__date__ = """$Date$"""
__version__ = """$Revision$"""
__credits__ = """Cuog, for helping me test.
David, for putting up with me.
Various IRC channels, for putting up with my (sometimes n00bish) questions.
PyGTK & Glade, for making this a little bit easier.
xchat-gnome, for lending me the speech bubble from their icon.
"""

_hostname = None
def getHost():
	global _hostname
	if _hostname is None:
		_hostname = unicode(socket.gethostname())
	return _hostname


def openmcastsock(group, port):
	"""
	Open a UDP socket, bind it to a port and select a multicast group
	Borrowed from the Python demos.
	"""
	#
	# Create a socket
	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	#
	# Allow multiple copies of this program on one machine
	# (not strictly needed)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	#
	# Bind it to the port
	s.bind(('', port))
	#
	# Look up multicast group address in name server
	# (doesn't hurt if it is already in ddd.ddd.ddd.ddd format)
	group = socket.gethostbyname(group)
	#
	# Construct binary group address
	bytes = map(int, group.split("."))
	grpaddr = 0
	for byte in bytes: grpaddr = (grpaddr << 8) | byte
	#
	# Construct struct mreq from grpaddr and ifaddr
	ifaddr = socket.INADDR_ANY
	mreq = struct.pack('ll', socket.htonl(grpaddr), socket.htonl(ifaddr))
	#
	# Add group membership
	s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
	#
	return s

HEADER_FORMAT = "!H"
ARGUMENT_FORMAT = "!L"

CMD_MESSAGE = 0
CMD_USER_JOIN = 1 # Also used as the response for a user list request
CMD_USER_PART = 2
CMD_LIST_USERS = 3

class Protocol(object):
	rsock = None
	ssock = None
	
	joiners = []
	parters = []
	msgers = []
	joined = False
	
	def __init__(self):
		# Sending stuff
		self.ssock = openmcastsock(SUBIM_GROUP, SUBIM_PORT)
		ttl = struct.pack('b', SUBIM_TTL) # Time-to-live
		self.ssock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)
		# Receiving stuff
		self.rsock = openmcastsock(SUBIM_GROUP, SUBIM_PORT)
		self.joined = False
	
	def __encode(self, uni):
		return unicode(uni).encode('utf8', 'ignore') # We really shouldn't get anything
	
	def __decode(self, data):
		return unicode(data, 'utf8', 'ignore')
	
	# SENDING #
	def __send(self, cmd, *args):
		args = map(unicode, args)
		print "Protocol.__send", cmd, args
		data = struct.pack(HEADER_FORMAT, cmd)
		args = [getHost()] + args # Prefix the username to the args
		for a in args:
			d = self.__encode(a)
			data += struct.pack(ARGUMENT_FORMAT, len(d))
			data += d
		self.ssock.sendto(data, (SUBIM_GROUP, SUBIM_PORT))
	
	def sendMessage(self, msg):
		print "Protocol.sendMessage", msg
		self.__send(CMD_MESSAGE, msg)
	
	def listUsers(self):
		print "Protocol.listUsers"
		#self.userJoin(getHost()) Shouldn't be needed, we'll reply to our own list
		self.__send(CMD_LIST_USERS)
	
	def join(self):
		print "Protocol.join"
		self.__send(CMD_USER_JOIN)
		self.joined = True
	
	def part(self):
		print "Protocol.part"
		self.joined = False
		self.__send(CMD_USER_PART)
	
	# RECEIVING #
	def recieveMessage(self, timestamp, src, user, msg):
		print "Protocol.recieveMessage", user, msg
		for c in self.msgers:
			if callable(c): c(timestamp, user, msg)
	
	def userJoin(self, timestamp, src, user):
		print "Protocol.userJoin", user
		for c in self.joiners:
			if callable(c): c(timestamp, user)
	
	def userPart(self, timestamp, src, user):
		print "Protocol.userPart", user
		for c in self.parters:
			if callable(c): c(timestamp, user)
		# If they're using the same name, send out a join message (we're still here)
		if user == getHost() and self.joined:
			self.join()
	
	def __reply2list(self, timestamp, src, user):
		self.__send(CMD_USER_JOIN)
	
	COMMANDS = {
		CMD_MESSAGE : recieveMessage,
		CMD_USER_JOIN : userJoin,
		CMD_USER_PART : userPart,
		CMD_LIST_USERS : __reply2list,
	}
	
	def __readPacket(self):
		dlen = struct.calcsize(HEADER_FORMAT)
		d,src = self.rsock.recvfrom(4096)
		timestamp = datetime.datetime.now()
		#print "__readPacket:", repr(d),src
		cmd, = struct.unpack(HEADER_FORMAT, d[:dlen])
		d = d[dlen:]
		args = []
		alen = struct.calcsize(ARGUMENT_FORMAT)
		while len(d) >= alen:
			l, = struct.unpack(ARGUMENT_FORMAT, d[:alen])
			d = d[alen:]
			args.append(self.__decode( d[:l] ))
			d = d[l:]
		if len(d):
			print "Warning: Leftover data: ", repr(d)
		if len(args) < 1:
			print "Warning: No user found"
		else:
			user = args[0]
			args = args[1:]
		return timestamp, src, cmd, user, args
	
	def readOne(self):
		timestamp, src, cmd, user, args = self.__readPacket()
		print "readOne:", src, cmd, user, args
		if cmd in self.COMMANDS:
			gobject.idle_add(self.COMMANDS[cmd],self, timestamp, src, user, *args)
	
	def readForever(self):
		print "Start reading"
		while True:
			try:
				self.readOne()
			except Exception, err:
				print type(err), err
				traceback.print_exc()
	
	def startReading(self):
		t = threading.Thread(target=self.readForever, name="SocketReader")
		t.setDaemon(True)
		t.start()
	
	def __enter__(self):
		self.join()
	
	def __exit__(self, exc_type=None, exc_value=None, traceback=None):
		self.part()

def hsl(H,S,L):
	"""
	http://discussion.forum.nokia.com/forum/showthread.php?t=78382#post199756
	"""
	def Hue_2_RGB( v1, v2, vH ):
		if ( vH < 0 ):
			vH += 1
		if ( vH > 1 ):
			vH -= 1
		if ( ( 6 * vH ) < 1 ):
			return ( v1 + ( v2 - v1 ) * 6 * vH )
		if ( ( 2 * vH ) < 1 ):
			return v2 
		if ( ( 3 * vH ) < 2 ):
			return ( v1 + ( v2 - v1 ) * ( ( 2 / 3 ) - vH ) * 6 )
		return v1 
	H = H / 360.0
	if (S == 0 ):
		R = L
		G = L
		B = L
	else:
		if ( L < 0.5 ):
			var_2 = L * ( 1 + S )
		else:
			var_2 = ( L + S ) - ( S * L )
		var_1 = 2 * L - var_2
		R = Hue_2_RGB( var_1, var_2, H + ( 1 / 3 ) )
		G = Hue_2_RGB( var_1, var_2, H )
		B = Hue_2_RGB( var_1, var_2, H - ( 1 / 3 ) )
	return (R,G,B)  

def getColorForUser(user):
	"""
	Algorithm borrowed from the chromatabs Firefox extension.
	"""
	def djb2hash(hashstring):
		hashvalue = 5381;
		for ascii_code in map(ord, hashstring):
			hashvalue = ((hashvalue << 5) + hashvalue) + ascii_code
		return hashvalue
	hue = djb2hash(user) % 360
	rgb = hsl(hue, SATURATION, LUMINANCE)
	rgb = tuple(map((lambda n: int(n * 0xFFFF)), rgb))
	return '#%04X%04X%04X' % rgb

def resource(fn,sec="share"):
	paths = [
		os.curdir, # For development
		os.path.join(sys.prefix, sec, 'subim'), # Assuming a single, global prefix
		# And now for some common prefix's
		'/'+os.path.join('usr', 'local', sec, 'subim'),
		'/'+os.path.join('usr', sec, 'subim'),
		# Relative to the script
		os.path.join(os.path.dirname(__file__), os.pardir, sec, 'subim'),
		# Now we're getting desparate
		os.path.join(os.pardir, sec, 'subim'),
		#FIXME: Handle windows installation
		]
	for path in paths:
		try:
			f = os.path.join(path, fn)
			if os.path.exists(f):
				return f
		except: pass
	else:
		print >> sys.stderr, "Couldn't find ", repr(fn)
		return fn #Can't actually find it

class MainWindow(object):
	def __listWidgets(self, root):
		"""
		Grabs the names of all the widgets and sets a property to that name.
		"""
		if not hasattr(root, 'get_children'): return
		for c in root.get_children():
			n = gtk.glade.get_widget_name(c)
			if n is None: 
				print "Not a Glade widget:", c
				continue # Wasn't an XML child
			setattr(self, n, c)
			self.__listWidgets(c)
	
	__initPanes = False
	def __init__(self, fn):
		self._xml = gtk.glade.XML(fn)
		self._xml.signal_autoconnect(self)
		self.wSubIM = self._xml.get_widget('wSubIM')
		self.__listWidgets(self.wSubIM) # Initialize all the props
		self.mStatusPopup = self._xml.get_widget('mStatusPopup')
		self.__listWidgets(self.mStatusPopup) # Initialize all the props
		
		self.wSubIM.set_icon_from_file(resource('subim.svg'))
		self.wSubIM.set_default_size(375, 500)
		
		self.tvUsers.append_column(gtk.TreeViewColumn('User', gtk.CellRendererText(), text=0))
		self.tvUsers.set_model(gtk.ListStore(str))
		self.umodel = self.tvUsers.get_model()
		self.umodel.set_sort_column_id(0, gtk.SORT_ASCENDING)
		self.tvUsers.sensitive = True
		self.userlist = []
		
		# System Tray icon
		if hasattr(gtk, 'status_icon_new_from_file'):
			self.siIcon = gtk.status_icon_new_from_file(resource('subim.svg')) #GTK 2.10
			self.siIcon.set_tooltip("SubIM - "+getHost())
			self.siIcon.set_visible(True)
			self.siIcon.connect("activate", self.statusActivate)
			self.siIcon.connect("popup-menu", self.statusPopup)
		else:
			self.siIcon = None
	
	def setUrgent(self):
		try:
			if self.wSubIM.get_property('has-toplevel-focus'): #GTK 2.4
				return
		except: pass
		if self.siIcon is not None:
			self.siIcon.set_blinking(True)
		self.wSubIM.set_property('urgency-hint', True) #GTK 2.6
	
	def clearUrgent(self):
		if self.siIcon is not None:
			self.siIcon.set_blinking(False)
		try:
			self.wSubIM.set_property('urgency-hint', False) #GTK 2.6
		except Exception, err:
			print type(err), err
	
	def statusActivate(self, icon):
		if self.siIcon is None:
			self.QuitApp()
		elif self.wSubIM.get_property('visible'):
			self.wSubIM.hide()
		else:
			self.wSubIM.present()
	
	def ShowAbout(self, item=None):
		if not hasattr(gtk,'AboutDialog'):
			return
		REV = re.compile(r"""\$Revision:(.*)\$""")
		m = REV.match(__version__)
		if m:
			ver = "r"+m.group(1).strip()
		else:
			ver = __version__
		PROPS = {
			'name' : 'SubIM',
			'comments' : "A dirt simple IM program for your local subnet",
			'logo' : self.wSubIM.get_icon(),
			'icon' : self.wSubIM.get_icon(),
			'version' : ver,
			'authors' : [__author__],
			'copyright' : "Â© 2007 James Bliss. Released under GNU GPL",
			'website' : 'http://www.astro73.com/',
		}
		try:
			f = file(resource('COPYING', 'share/doc'))
			PROPS['license'] = f.read()
			f.close()
			del f
		except: pass
		ad = gtk.AboutDialog() #GTK 2.6
		for k,v in PROPS.items():
			try:
				ad.set_property(k,v)
			except Exception, err:
				print type(err), err
		def resp(dlg, r):
			if r in [gtk.RESPONSE_OK, gtk.RESPONSE_CANCEL, gtk.RESPONSE_CLOSE, 
					gtk.RESPONSE_YES, gtk.RESPONSE_NO]:
				dlg.hide()
				dlg.destroy()
		ad.connect('response', resp)
		ad.present()
	
	def QuitApp(self, item=None):
		self.wSubIM.hide()
		self.wSubIM.destroy()
		gtk.main_quit()
	
	def statusPopup(self, icon, button, time):
		print "statusPopup", icon, button, time
		self.mStatusPopup.popup(None, None, gtk.status_icon_position_menu, \
		                        button, time, icon)
	
	def winDelete(self, widget, event):
		print "winDelete", widget, event
		if self.siIcon is None:
			self.QuitApp()
		else:
			self.wSubIM.hide()
			return True # Override
	
	def focusHandler(self, *p):
		#print "focusHandler", p
		#print datetime.datetime.now(),"\t",p[1].type
		self.clearUrgent()
	
	def present(self):
		self.wSubIM.present()
		self.clearUrgent()
		# Frankly, these two should be in the glade file
		self.tvMessage.grab_focus()
		self.bSend.grab_default()
		# And the fact that I have to do this after presenting is a little ridiculous
		# _And_ they should be in the glade file
		if not self.__initPanes:
			self.vpInput.set_position(self.vpInput.get_position() - 50)
			self.hpUsers.set_position(self.hpUsers.get_position() - 75)
			self.__initPanes = True
	
	def getMessageText(self):
		buf = self.tvMessage.get_buffer()
		rv = buf.get_text(*buf.get_bounds())
		print "getMessageText:rv", type(rv), repr(rv)
		return unicode(rv, 'utf8', 'ignore')
	
	def sendMessage(self, *p, **kw):
		print "sendMessage", p, kw
		protocol.sendMessage(self.getMessageText())
		# Clear the input
		buf = self.tvMessage.get_buffer()
		buf.delete(*buf.get_bounds())
	
	def addUser(self, time, userName):
		print "addUser", userName
		if userName not in self.userlist:
			self.userlist.append(userName)
			self.addNotice(time, userName, "joined")
			i = self.umodel.append([userName])
			assert self.tvUsers.get_model() is self.umodel
	
	def rmUser(self, time, userName):
		print "rmUser", userName
		if userName in self.userlist:
			i = self.userlist.index(userName)
			del self.userlist[i]
			self.addNotice(time, userName, "left")
			for i in range(0, len(self.umodel)):
				if self.umodel[i][0] == userName:
					del self.umodel[i]
					return
	
	def sendMessageKey(self, widget, event):
		if event.type != gtk.gdk.KEY_PRESS: return
		#print "sendMessageKey", hex(event.state), hex(event.keyval), event.group, repr(event.string)
		if event.keyval == 0xFF0D or event.string == "\r":
			if event.state & 1: #Shift
				event.state &= ~1
				return False # Continue processing
			else: #Unshifted
				#self.bSend.emit("clicked")
				self.wSubIM.activate_default()
				return True # Stop processing
		elif event.keyval == 0xFF09: # Tab, for tab completion
			pass
	
	def scrollDown(self):
		"""
		Scroll to the bottom of the history.
		"""
		#FIXME: Sometimes, this causes the text to disappear
		va = self.swHistory.get_vadjustment()
		print "va:", va.lower, va.value, va.upper, va.page_size
		va.set_value(va.upper)
	
	def getTime(self, dt):
		dt = datetime.datetime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, 0, dt.tzinfo)
		return u"[%s] " % unicode(dt)
	
	_first = True
	def __addText(self, list):
		buf = self.tvHistory.get_buffer()
		if not self._first:
			buf.insert(buf.get_bounds()[1], "\n")
		self._first = False
		for txt, attrs in list:
			if attrs is None:
				buf.insert(buf.get_bounds()[1], txt)
			else:
				ut = buf.create_tag(**dict(attrs))
				buf.insert_with_tags(buf.get_bounds()[1], txt, ut)
		self.setUrgent()
		self.scrollDown()
	
	def addMessage(self, time, user, msg):
		self.__addText([
			(self.getTime(time)+user+":", dict(foreground=getColorForUser(user))),
			(" "+msg.strip(), None),
		])
	
	def addNotice(self, time, user, msg):
		"""
		Like addMessage, but for things like quit/join.
		"""
		self.__addText([
			(self.getTime(time), None),
			(user+" "+msg.strip(), dict(weight=pango.WEIGHT_BOLD)),
		])
	
	def addAction(self, time, user, msg):
		self.__addText([
			(self.getTime(time), dict(foreground=getColorForUser(user))),
			("***"+user, dict(weight=pango.WEIGHT_BOLD,foreground=getColorForUser(user))),
			(" "+msg.strip(), None),
		])
	

if __name__ == '__main__':
	app = MainWindow(resource('subim.glade'))
	print repr(app)
	protocol = Protocol()
	
	def msgRecv(time, user, msg):
		global app
		if msg.startswith('/me'):
			app.addAction(time,user,msg[len('/me'):])
		else:
			app.addMessage(time, user, msg)
	def userJoined(time, user):
		global app
		app.addUser(time, user)
	def userParted(time, user):
		global app
		app.rmUser(time, user)
	
	protocol.joiners.append(userJoined)
	protocol.parters.append(userParted)
	protocol.msgers.append(msgRecv)
	
	protocol.startReading()
	
#	with protocol: Compatiblity with debian stable
	protocol.__enter__()
	try:
		protocol.listUsers()
		app.present()
		gtk.gdk.set_show_events(True)
		gtk.main()
	finally:
		protocol.__exit__()

