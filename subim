#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import with_statement
import pygtk
pygtk.require('2.0')
import gtk
gtk.threads_init()
import gtk.glade
import gobject
import os, sys, socket, struct, threading

# The IPv4 multicast group is 224.0.0.0/4
# The mcast.py demo uses 225.0.0.250, which is part of a reserved block
# The link scope is 239.255.0.0/16, the organization scope is 239.192.0.0/14
# I'm going to use the latter, with the last 2 bytes being map(ord, 'SI')
SUBIM_GROUP = '239.192.83.73'
# Set this to the number of hops packets can take. 1 is fine for most homes,
# Organizations or other more complex setups may need higher numbers.
SUBIM_TTL = 1

# Change this to 8123 to test with mcast.py found in the Python demos
SUBIM_PORT = 5349 # map(hex, map(ord, 'SI')), SI = SubIM

_hostname = None
def getHost():
	global _hostname
	if _hostname is None:
		_hostname = unicode(socket.gethostname())
	return _hostname


# Open a UDP socket, bind it to a port and select a multicast group
def openmcastsock(group, port):
	"""
	Open a UDP socket, bind it to a port and select a multicast group
	Borrowed from the Python demos.
	"""
	#
	# Create a socket
	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	#
	# Allow multiple copies of this program on one machine
	# (not strictly needed)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	#
	# Bind it to the port
	s.bind(('', port))
	#
	# Look up multicast group address in name server
	# (doesn't hurt if it is already in ddd.ddd.ddd.ddd format)
	group = socket.gethostbyname(group)
	#
	# Construct binary group address
	bytes = map(int, group.split("."))
	grpaddr = 0
	for byte in bytes: grpaddr = (grpaddr << 8) | byte
	#
	# Construct struct mreq from grpaddr and ifaddr
	ifaddr = socket.INADDR_ANY
	mreq = struct.pack('ll', socket.htonl(grpaddr), socket.htonl(ifaddr))
	#
	# Add group membership
	s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
	#
	return s

HEADER_FORMAT = "!HL"
ARGUMENT_FORMAT = "!L"

CMD_MESSAGE = 0
CMD_USER_JOIN = 1 # Also used as the response for a user list request
CMD_USER_PART = 2
CMD_LIST_USERS = 3

NUM_ARGS = {
	CMD_MESSAGE : 1,
	CMD_USER_JOIN : 0,
	CMD_USER_PART : 0,
	CMD_LIST_USERS : 0,
}

class Protocol(object):
	sock = None
	
	joiners = []
	parters = []
	msgers = []
	
	def __init__(self):
		self.sock = openmcastsock(SUBIM_GROUP, SUBIM_PORT)
		ttl = struct.pack('b', SUBIM_TTL) # Time-to-live
		self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)
		self.sock.connect((SUBIM_GROUP, SUBIM_PORT))
	
	def __encode(self, uni):
		return unicode(uni).encode('utf8', 'ignore') # We really shouldn't get anything
	
	def __decode(self, data):
		return unicode(data, 'utf8', 'ignore')
	
	def __readHeader(self):
		l = struct.calcsize(HEADER_FORMAT)
		d = self.sock.read(l)
		cmd, ulen = struct.unpack(HEADER_FORMAT, d)
		user = self.sock.read(ulen)
		return cmd, self.__decode(user)
	
	def __readArgument(self):
		l = struct.calcsize(ARGUMENT_FORMAT)
		d = self.sock.read(l)
		ulen, = struct.unpack(ARGUMENT_FORMAT, d)
		data = self.sock.read(ulen)
		return self.__decode(data)
	
	def __send(self, cmd, *args):
		args = map(unicode, args)
		print "Protocol.__send", cmd, args
		user = unicode(getHost()).encode('utf8', 'ignore')
		data = struct.pack(HEADER_FORMAT, cmd, len(user))
		data += user
		for a in args:
			d = self.__encode(a)
			data += struct.pack(ARGUMENT_FORMAT, len(d))
			data += d
		self.sock.sendall(data)
	
	def sendMessage(self, msg):
		print "Protocol.sendMessage", msg
		self.__send(CMD_MESSAGE, msg)
	
	def recieveMessage(self, user, msg):
		print "Protocol.recieveMessage", user, msg
		for c in self.msgers:
			if callable(c): c(user, msg)
	
	def userJoin(self, user):
		print "Protocol.userJoin", user
		for c in self.joiners:
			if callable(c): c(user)
	
	def userPart(self, user):
		print "Protocol.userPart", user
		for c in self.parters:
			if callable(c): c(user)
	
	def listUsers(self):
		print "Protocol.listUsers"
		self.userJoin(getHost())
		self.__send(CMD_LIST_USERS)
	
	def join(self):
		print "Protocol.join"
		self.userJoin(getHost())
		self.__send(CMD_USER_JOIN)
	
	def part(self):
		print "Protocol.part"
		self.__send(CMD_USER_PART)
		self.userPart(getHost())
	
	def __reply2list(self):
		self.__send(CMD_USER_JOIN)
	
	COMMANDS = {
		CMD_MESSAGE : recieveMessage,
		CMD_USER_JOIN : userJoin,
		CMD_USER_PART : userPart,
		CMD_LIST_USERS : __reply2list,
	}
	
	def readOne(self):
		cmd, user = self.__readHeader()
		args = []
		if cmd in NUM_ARGS:
			args = [self.__readArgument() for i in range(NUM_ARGS[cmd])]
		if cmd in self.COMMANDS:
			self.COMMANDS[cmd](self, user, *args)
	
	def readForever(self):
		while True:
			self.readOne()
	
	def startReading(self):
		t = threading.Thread(target=self.readForever, name="SocketReader")
		t.setDaemon(True)
		t.start()
	
	def __enter__(self):
		self.join()
	
	def __exit__(self, exc_type, exc_value, traceback):
		self.part()

def getColorForUser(user):
	return 'red'

def resource(fn):
	if os.path.exists(os.path.join('/usr/lib/subim', fn)):
		return os.path.join('/usr/lib/subim', fn)
	else:
		return fn

class MainWindow(object):
	def __init__(self, fn):
		self.xml = gtk.glade.XML(fn, 'wSubIM')
		self.xml.signal_autoconnect(self)
		self._win = self.xml.get_widget('wSubIM')
		self._msg = self.xml.get_widget('tvMessage')
		self._hist = self.xml.get_widget('tvHistory')
		self._users = self.xml.get_widget('tvUsers')
		self._users.append_column(gtk.TreeViewColumn('User', gtk.CellRendererText(), text=0))
		self._users.set_model(gtk.ListStore(str))
		self.umodel = self._users.get_model()
		self.umodel.set_sort_column_id(0, gtk.SORT_ASCENDING)
		self._users.sensitive = True
	
	def winDelete(self, widget, event):
		print "winDelete", widget, event
		gtk.main_quit(0)
	
	def present(self):
		self._win.present()
	
	def getMessageText(self):
		buf = self._msg.get_buffer()
		rv = buf.get_text(*buf.get_bounds())
		print "getMessageText:rv", type(rv), repr(rv)
		return unicode(rv, 'utf8', 'ignore')
	
	def sendMessage(self, *p, **kw):
		print "sendMessage", p, kw
		protocol.sendMessage(self.getMessageText())
		self.addMessage(getHost(), self.getMessageText())
		# Clear the input
		buf = self._msg.get_buffer()
		buf.delete(*buf.get_bounds())
		# Scroll to the bottom
		va = self.xml.get_widget('swHistory').get_vadjustment()
		va.set_value(va.upper)
	
	def addUser(self, userName):
		print "FIXME: addUser", userName
		if [userName] in self.umodel: return
		i = self.umodel.append([userName])
		print "addUser:i", self.umodel.get_path(i)
		assert self._users.get_model() is self.umodel
		print "addUser:model", map(list,self.umodel)
	
	def rmUser(self, userName):
		print "FIXME: rmUser", userName
		for i in range(0, len(self.umodel)):
			if self.umodel[i][0] == userName:
				del self.umodel[i]
				return
	
	_first = True
	def addMessage(self, user, msg):
		buf = self._hist.get_buffer()
		if not self._first:
			buf.insert(buf.get_bounds()[1], "\n")
		self._first = False
		ut = buf.create_tag(foreground=getColorForUser(user))
		buf.insert_with_tags(buf.get_bounds()[1], user+":", ut)
		buf.insert(buf.get_bounds()[1], " "+msg.strip())
	

if __name__ == '__main__':
	app = MainWindow(resource('subim.glade'))
	print repr(app)
	protocol = Protocol()
	
	def msgRecv(user, msg):
		global app
		app.addMessage(user, msg)
	def userJoined(user):
		global app
		app.addUser(user)
	def userParted(user):
		global app
		app.rmUser(user)
	
	protocol.joiners.append(userJoined)
	protocol.parters.append(userParted)
	protocol.msgers.append(msgRecv)
	
	with protocol:
		protocol.listUsers()
		app.present()
		gtk.main()

